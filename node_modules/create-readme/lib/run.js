// Generated by CoffeeScript 2.3.2
(function() {
  var OptionsParser, PackageJSONReader, Promise, ReadmeCreator, TemplateLoader, fs, logger, mustache, path, program, requireAll;

  program = require('commander');

  Promise = require('bluebird');

  fs = Promise.promisifyAll(require('fs'));

  mustache = require('mustache');

  logger = require('./logger');

  requireAll = require('require-all');

  path = require('path');

  PackageJSONReader = require('./pkg-json');

  OptionsParser = require('./options');

  TemplateLoader = require('./template');

  // Creates a README.md based on information from package.json and other files
  module.exports = ReadmeCreator = class ReadmeCreator {
    // Creates a new ReadmeCreator
    // @param (options) [Object] An optional set of options. See the individual components for details
    // @option options silent [Boolean] Do not write anything to stdout
    // @option options debug [Boolean] Write useful debug messages to stdout
    constructor(options) {
      if (options.silent) {
        logger.level = 'silent';
      }
      if (options.debug) {
        logger.level = 'debug';
        if (options.silent) {
          logger.warn("Tried to set both silent and debug flag");
        }
      }
      if (options.silly) {
        logger.level = 'silly';
        if (options.silent) {
          logger.warn("Tried to set both silent and silly flag");
        }
        if (options.debug) {
          logger.warn("Tried to set both debug and silly flag");
        }
      }
      logger.silly("------------------------------------------------");
      logger.silly("Module invoked with options");
      logger.silly(JSON.stringify(options, null, 2));
      logger.silly("------------------------------------------------");
      this.pkg = new PackageJSONReader(options).read();
      this.options = new OptionsParser().parse(this.pkg, options);
    }

    // Parse the readme data
    // @return [Promise] A promise for the data needed for rendering the template
    parse() {
      return Promise.props(requireAll({
        dirname: path.join(__dirname, 'components'),
        filter: /(.*)\.(?:coffee|js)/, // .coffee and .js files
        resolve: (Component) => {
          return new Component(this.options).run(this.pkg).tap(function() {
            return logger.debug(Component.name + " done");
          });
        }
      }));
    }

    // Render the content to the README file template
    // @param content [Object] An object with the data needed for the template
    // @returns [Promise<String>] The rendered template
    render(content) {
      var template;
      logger.debug("Starting render");
      template = new TemplateLoader(this.options).loadTemplate();
      return Promise.join(template, content, function(template, content) {
        logger.silly("---------------------------------");
        logger.silly("Data used for rendering:");
        logger.silly(JSON.stringify(content, null, 2));
        logger.silly("---------------------------------");
        return mustache.render(template, content);
      });
    }

    // Write the given content to the README file
    // @param content [String] The content to write
    // @return [Promise] A promise that resolves when the writing was successful
    write(content) {
      logger.debug("Starting write");
      return content.then((content) => {
        logger.silly("---------------------------------");
        logger.silly("Wrote to file:");
        logger.silly(content);
        logger.silly("---------------------------------");
        return fs.writeFileAsync(this.options.filename, content);
      });
    }

    // Run the script
    // @overload run(args, cb)
    //   @param args [Array] The arguments to the script.
    //   @param cb [Function] A node-style callback that will be called with any error encountered
    // @overload run(args)
    //   @param args [Array] The arguments to the script.
    //   @return [Promise] A promise that rejects with any errors encountered
    static run(args = [], cb) {
      var content, data, i, len, list, optionName, optionNames, options, readme, readmeCreator, ref, rejection;
      list = function(v) {
        return v.split(',');
      };
      optionNames = ['filename', 'debug', 'silent', 'silly', 'encoding', 'addDesc', 'modules', 'unpkg', 'packagePath', 'licenseFile', 'badges', 'branch', 'docFile', 'replaceReferences'];
      program.usage('[options] <file>').option('-d, --debug', 'Debug logging mode').option('-s, --silent', 'Silent logging mode').option('--silly', 'Silly logging mode').option('--encoding <enc>', 'Encoding to use to read files ["utf-8"]').option('-a, --add-desc <text>', 'Text to add to the description [""]').option('-u, --add-usage <text>', 'Text to add to the usage section [""]').option('-m, --modules <modules>', 'List of support module types ' + '["CommonJS"]', list).option('-n, --unpkg', 'Delivery by unpkg.com').option('-p, --package-path <path>', 'Path to package.json from cwd ["./package.json"]').option('--license-file <file>', 'Name of the license file ["LICENSE"]').option('-b, --badges <badges>', 'Badges to use ["npm-version,travis,coveralls,' + 'dependencies,devDependencies,gitter,circleci,minzipped,npm-downloads,' + 'open-issues,license,semantic-release,debug,greenkeeper"]', list).option('--branch <branch>', 'Branch to use for the documentation ["master"]').option('--doc-file <file>', 'Main html file for the documentation ["index.html"]').option('--no-replace-references', 'No replacement of "../" in examples').option('--replace-references', 'Force replacement of "../" in examples').parse(args);
      if (program.args.length > 1) {
        rejection = Promise.reject('Only 1 file can be created, files ' + program.args.split(',') + ' were given');
        if (cb != null) {
          rejection.catch(function(err) {
            throw err;
            return cb(1);
          });
          return;
        } else {
          return rejection;
        }
      }
      program.filename = (ref = program.args) != null ? ref[0] : void 0;
      if (program.enableReplaceReferences && program.disableReplaceReferences) {
        logger.warn('Set both --enable-replace-references as well as ' + '--disable-replace-refrences');
      }
      if (program.replaceReferences == null) {
        program.replaceReferences = program.noReplaceReferences != null ? false : null;
      }
      options = {};
      for (i = 0, len = optionNames.length; i < len; i++) {
        optionName = optionNames[i];
        if (program[optionName] != null) {
          options[optionName] = program[optionName];
        }
      }
      if (!rejection) {
        readmeCreator = new ReadmeCreator(options);
        data = readmeCreator.parse();
        content = readmeCreator.render(data);
        readme = readmeCreator.write(content);
      }
      if (cb != null) {
        readme.then(function() {
          return cb();
        }).catch(function(err) {
          throw err;
          return cb(1);
        });
      } else {
        return readme;
      }
    }

  };

}).call(this);
